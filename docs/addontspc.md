
# ДОПОЛНЕНИЕ К ТЗ: поддержка jagged-веток через алгоритмические агрегаты

## A) Новое требование: разрешить jagged arrays, но только через агрегирование

**Считать допустимыми признаки**, если ветка на событие является массивом чисел (jagged), и для неё вычисляются **строго заданные агрегаты**, дающие **одно число на событие**.

### Запрещено

* интерпретировать элементы массива,
* фильтровать “по смыслу”,
* выбирать “первый мюон” или “лучший трек” и т.п.

### Разрешено

* только математические агрегаторы и простые детерминированные правила выбора индексов (например, max/min), без “семантики”.

---

## B) Конфиг: новые параметры

Добавить в YAML:

```yaml
allow_jagged: true

# Какие jagged-ветки использовать (если null → авто-выбор числовых jagged)
jagged_branches: null

# Список агрегаторов, которые нужно вычислять для каждой jagged-ветки
jagged_aggs:
  - len            # длина массива
  - sum
  - mean
  - std
  - min
  - max
  - q25
  - median
  - q75
  - l2             # sqrt(sum(x^2))

# Ограничение на число jagged-веток (чтобы не раздувать d)
max_jagged_branches: 8

# Ограничение на число скалярных веток (как раньше)
max_scalar_branches: 32
```

---

## C) Правка “Шаг 2 — выбрать ветки”

### C1) Скалярные ветки

Оставить как есть.

### C2) Jagged-ветки (новое)

Если `allow_jagged=true`:

1. На первых `max_scan=20000` событиях найти ветки, которые:

   * являются массивами чисел (var-length list of float/int),
   * доля пустых массивов ≤ 50% (иначе слишком разрежено),
   * по объединённой выборке значений std > 0.
2. Взять не более `max_jagged_branches` веток:

   * приоритет: меньше пустых и больше дисперсия.
3. Для каждой выбранной jagged-ветки построить **вектор агрегатов** из списка `jagged_aggs`.
4. Итоговый список признаков для `O`:

   * все скалярные ветки (как раньше),
   * плюс агрегаты каждой jagged-ветки, именованные так:

     * `<branch>__<agg>`
       пример: `Muon_pt__mean`, `Muon_eta__std`, `Muon_charge__len`

**Важно:** если в исходном ROOT почти всё jagged (как в твоём случае), то d формируется именно этим блоком.

---

## D) Правка “Шаг 3 — первый проход статистик”

Теперь статистики нужно считать **для итоговых скалярных признаков**, включая агрегаты jagged.

То есть `branch_stats.csv` должен включать строки:

* `nMuon`
* `Muon_pt__len`
* `Muon_pt__mean`
* …
  и т.д.

Правила NaN:

* если массив пустой:

  * `len=0`
  * для sum/mean/std/min/max/quantiles/l2 → ставить NaN, а затем импутировать median по признаку.

---

## E) Алгоритм вычисления агрегатов jagged (строго)

Пусть `a` — массив чисел длины `m` для события.

* `len(a) = m`
* если `m==0`:

  * `len=0`, остальные = NaN
* иначе:

  * `sum = Σ a_i`
  * `mean = (Σ a_i)/m`
  * `std = sqrt(mean((a-mean)^2))` (population std)
  * `min`, `max`
  * `median`, `q25`, `q75` по стандартным квантилям
  * `l2 = sqrt(Σ a_i^2)`

Никаких иных функций.

---

## F) Правка “Шаг 4 — построение Π_obs”

`O` строится уже по **расширенному скалярному X** (scalar + jagged_aggs).

Остальное без изменений:

* `quantile` / `zscore`
* bins=16 по умолчанию

---

## G) Дополнительные выходы (минимальные)

Добавить файл:

* `derived_features.json`
  где перечислено:

  * какие jagged-ветки выбраны,
  * какие агрегаторы применены,
  * итоговый список признаков.

---

## H) Приёмка (обновление критериев)

Добавить к критериям:

5. Если в ROOT присутствуют числовые jagged-ветки и `allow_jagged=true`, то:

* итоговое число признаков должно быть **>1**, и
* `d` (размерность O) должна быть **>16** при bins=16, иначе считается вырожденным прогоном.

---

# Минимальный “железный” набор для твоего файла

Чтобы не раздувать d и при этом получить структуру, для конкретного случая `Muon_*` достаточно:

* использовать jagged ветки:

  * `Muon_pt`, `Muon_eta`, `Muon_phi`, `Muon_mass`, `Muon_charge`
* агрегаторы (короткий набор):

  * `len, mean, std, min, max, l2`
    Это уже даёт порядка 5×6 = 30 признаков + `nMuon` → 31 признак.

При `bins=16`:

* d ≈ 31×16 = 496 → отлично (и ещё влезает в полный `eigh`, если захотите).

---
